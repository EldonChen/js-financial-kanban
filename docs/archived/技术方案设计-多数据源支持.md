# 技术方案设计 - 股票基本信息模块多数据源支持

> **项目状态**：设计阶段  
> **创建时间**：2024年  
> **文档位置**：docs/

## 项目概述

提升股票基本信息模块的**健壮性、可用性与市场覆盖范围**，通过引入并集成多个股票基础数据 API，逐步降低对单一数据源（yfinance）的依赖，并支持多个股票市场（A 股、港股、美股等）。

## 项目技术关键点

### 1. 核心目标

- **降低单一依赖**：不再强依赖 yfinance，支持多个数据源
- **市场覆盖扩展**：支持 A 股、港股、美股等多个市场
- **提升可用性**：数据源故障时自动切换备用数据源
- **数据完整性**：支持获取全量股票列表（如某市场所有上市公司）

### 2. 技术栈选型

#### 现有技术栈（保持不变）
- **框架**: FastAPI
- **数据库**: MongoDB
- **数据库驱动**: Motor（异步）
- **数据验证**: Pydantic 2.x
- **包管理**: uv

#### 新增技术栈
- **数据源抽象层**: 自定义 Provider/Adapter 模式
- **数据源库**（按优先级排序）:
  
  **第一优先级：免费优先、无需认证**
  - **akshare**（A 股/港股/美股，免费开源，无需认证）⭐
  - **yfinance**（美股/港股，已使用，免费，无需认证）⭐
  - **easyquotation**（A 股实时行情，免费，无需认证）
  
  **第二优先级：需要注册 API Key，存在限制**
  - **Tushare**（A 股数据，需要 token，免费但有积分限制）
  - **IEX Cloud**（美股数据，需要 API Key，免费版 50,000 次/月）
  - **Alpha Vantage**（美股数据，需要 API Key，免费版 5 次/分钟）
  - **Finnhub**（美股数据，需要 API Key，免费版 60 次/分钟）

## 架构设计决策

### 1. 数据源抽象层设计

#### 1.1 Provider 接口定义

```python
from abc import ABC, abstractmethod
from typing import Optional, Dict, Any, List

class StockDataProvider(ABC):
    """股票数据提供者抽象基类."""
    
    @property
    @abstractmethod
    def name(self) -> str:
        """数据源名称."""
        pass
    
    @property
    @abstractmethod
    def supported_markets(self) -> List[str]:
        """支持的市场列表（如 ['A股', '港股', '美股']）."""
        pass
    
    @abstractmethod
    async def fetch_stock_info(self, ticker: str, market: Optional[str] = None) -> Optional[Dict[str, Any]]:
        """获取单个股票信息.
        
        Args:
            ticker: 股票代码
            market: 市场类型（可选，用于区分不同市场的相同代码）
        
        Returns:
            股票信息字典，如果失败返回 None
        """
        pass
    
    @abstractmethod
    async def fetch_all_tickers(self, market: Optional[str] = None) -> List[str]:
        """获取所有股票代码列表.
        
        Args:
            market: 市场类型（可选）
        
        Returns:
            股票代码列表
        """
        pass
    
    @abstractmethod
    async def is_available(self) -> bool:
        """检查数据源是否可用.
        
        Returns:
            是否可用
        """
        pass
```

#### 1.2 数据源适配器实现

每个数据源实现 `StockDataProvider` 接口：

- **YFinanceProvider**: 现有 yfinance 数据源（美股/港股）
- **TushareProvider**: Tushare 数据源（A 股）
- **EasyQuotationProvider**: easyquotation 数据源（A 股实时行情）
- **StockApiProvider**: stock-api 数据源（A 股）

#### 1.3 数据源路由器

```python
class StockDataRouter:
    """数据源路由器，负责选择合适的数据源."""
    
    def __init__(self):
        self.providers: Dict[str, StockDataProvider] = {}
        self.market_providers: Dict[str, List[str]] = {}  # 市场 -> 数据源列表（优先级顺序）
    
    def register_provider(self, provider: StockDataProvider):
        """注册数据源."""
        self.providers[provider.name] = provider
        # 更新市场映射
        for market in provider.supported_markets:
            if market not in self.market_providers:
                self.market_providers[market] = []
            self.market_providers[market].append(provider.name)
    
    async def fetch_stock_info(
        self, 
        ticker: str, 
        market: Optional[str] = None,
        preferred_provider: Optional[str] = None
    ) -> Optional[Dict[str, Any]]:
        """获取股票信息（带容错）.
        
        按优先级尝试多个数据源，直到成功或所有数据源都失败。
        """
        # 1. 如果指定了首选数据源，先尝试
        if preferred_provider and preferred_provider in self.providers:
            provider = self.providers[preferred_provider]
            if await provider.is_available():
                result = await provider.fetch_stock_info(ticker, market)
                if result:
                    return result
        
        # 2. 根据市场选择数据源列表
        if market:
            provider_names = self.market_providers.get(market, [])
        else:
            provider_names = list(self.providers.keys())
        
        # 3. 按优先级尝试
        for provider_name in provider_names:
            provider = self.providers[provider_name]
            if not await provider.is_available():
                continue
            
            try:
                result = await provider.fetch_stock_info(ticker, market)
                if result:
                    return result
            except Exception as e:
                logger.warning(f"数据源 {provider_name} 获取股票 {ticker} 失败: {e}")
                continue
        
        return None
```

### 2. 数据模型扩展

#### 2.1 股票基本信息字段扩展

```python
{
  "_id": ObjectId,
  "ticker": "AAPL",              # 股票代码（唯一标识）
  "name": "Apple Inc.",          # 股票名称
  "market": "NASDAQ",            # 市场（NASDAQ, NYSE, SSE, SZSE, HKEX 等）
  "market_type": "美股",         # 市场类型（美股、A股、港股）
  "sector": "Technology",         # 行业板块
  "industry": "Consumer Electronics",  # 细分行业
  "currency": "USD",             # 货币
  "exchange": "NMS",             # 交易所代码
  "country": "United States",    # 国家
  "data_source": "yfinance",     # 数据来源
  "listing_date": ISODate,       # 上市日期（新增）
  "market_cap": float,           # 市值（新增）
  "pe_ratio": float,            # 市盈率（新增）
  "pb_ratio": float,            # 市净率（新增）
  "dividend_yield": float,      # 股息率（新增）
  "industry_classification": str, # 行业分类（新增，如申万行业分类）
  "concept_tags": List[str],     # 概念标签（新增，如"人工智能"、"新能源"）
  "last_updated": ISODate,       # 最后更新时间
  "created_at": ISODate,         # 创建时间
  "updated_at": ISODate          # 更新时间
}
```

#### 2.2 字段映射策略

不同数据源返回的字段可能不同，需要统一映射：

```python
class FieldMapper:
    """字段映射器，将不同数据源的字段映射到统一格式."""
    
    @staticmethod
    def map_yfinance(info: Dict[str, Any]) -> Dict[str, Any]:
        """映射 yfinance 数据."""
        return {
            "ticker": info.get("symbol", "").upper(),
            "name": info.get("longName") or info.get("shortName", ""),
            "market": info.get("exchange", ""),
            "market_type": "美股" if info.get("exchange") in ["NASDAQ", "NYSE"] else "港股",
            "sector": info.get("sector", ""),
            "industry": info.get("industry", ""),
            "currency": info.get("currency", "").upper(),
            "exchange": info.get("exchange", ""),
            "country": info.get("country", ""),
            "market_cap": info.get("marketCap"),
            "pe_ratio": info.get("trailingPE"),
            "pb_ratio": info.get("priceToBook"),
            "dividend_yield": info.get("dividendYield"),
            "data_source": "yfinance",
        }
    
    @staticmethod
    def map_tushare(data: Dict[str, Any]) -> Dict[str, Any]:
        """映射 Tushare 数据."""
        return {
            "ticker": data.get("ts_code", "").split(".")[0],  # 如 "000001.SZ" -> "000001"
            "name": data.get("name", ""),
            "market": data.get("exchange", ""),  # SSE, SZSE
            "market_type": "A股",
            "sector": data.get("industry", ""),
            "industry": data.get("industry", ""),
            "currency": "CNY",
            "exchange": data.get("exchange", ""),
            "country": "China",
            "listing_date": data.get("list_date"),  # 上市日期
            "data_source": "tushare",
        }
```

### 3. 服务层改造

#### 3.1 数据源服务集成

```python
class StockService:
    """股票数据服务（改造后）."""
    
    def __init__(self, db: Optional[AsyncIOMotorDatabase] = None, router: Optional[StockDataRouter] = None):
        self.db = db if db is not None else get_database()
        self.collection = self.db.stocks
        self.router = router or get_stock_data_router()  # 获取全局路由器
    
    async def update_stock_from_provider(
        self, 
        ticker: str, 
        market: Optional[str] = None,
        preferred_provider: Optional[str] = None
    ) -> Optional[Dict[str, Any]]:
        """从数据源抓取并更新股票数据（支持多数据源）.
        
        Args:
            ticker: 股票代码
            market: 市场类型（可选）
            preferred_provider: 首选数据源（可选）
        
        Returns:
            更新后的股票信息，如果抓取失败返回 None
        """
        # 使用路由器获取股票信息（自动容错）
        stock_data = await self.router.fetch_stock_info(
            ticker, 
            market=market, 
            preferred_provider=preferred_provider
        )
        
        if not stock_data:
            logger.warning(f"股票 {ticker} 数据抓取失败（所有数据源都失败）")
            return None
        
        # 更新到数据库
        updated_stock = await self.upsert_stock(stock_data)
        logger.info(f"股票 {ticker} 更新成功（数据源: {stock_data.get('data_source')}）")
        return updated_stock
```

## 技术难点与解决方案

### 1. 不同市场股票代码格式差异

**问题**：
- A 股：6 位数字（如 "000001"），可能带后缀（如 "000001.SZ"）
- 港股：5 位数字（如 "00700"），或带后缀（如 "00700.HK"）
- 美股：1-5 位字母（如 "AAPL"）

**解决方案**：
- 在数据源适配器中统一处理代码格式
- 存储时统一格式（去除后缀，统一大小写）
- 查询时支持多种格式输入

### 2. 数据源可用性检测

**问题**：如何快速检测数据源是否可用？

**解决方案**：
- 实现轻量级的健康检查（如 ping API 端点）
- 缓存可用性状态（避免频繁检查）
- 失败后自动重试（指数退避）

### 3. 数据源认证和配置

**问题**：某些数据源需要 API Key（如 Tushare）。

**解决方案**：
- 使用环境变量管理配置
- 支持可选配置（如果未配置，则跳过该数据源）
- 在启动时验证配置有效性

### 4. 数据字段差异处理

**问题**：不同数据源返回的字段可能不同。

**解决方案**：
- 定义统一的数据模型（Pydantic Schema）
- 使用字段映射器转换数据
- 缺失字段使用 None 或默认值

### 5. 数据源切换策略

**问题**：如何决定使用哪个数据源？

**解决方案**：
- 按市场配置数据源优先级
- 支持手动指定首选数据源
- 自动容错：主数据源失败时自动切换到备用数据源

## 技术选型依据

### 1. 为什么选择 Provider/Adapter 模式？

- **解耦**：数据源与业务逻辑解耦，易于扩展
- **可测试性**：可以轻松 mock 数据源进行测试
- **灵活性**：可以动态添加/移除数据源

### 2. 数据源优先级策略

根据项目需求，采用**"免费优先、无需认证"**的优先级策略：

#### 第一优先级：免费优先、无需认证

**akshare（A 股主数据源）**：
- ✅ **完全免费**：无需注册，无需 API Key
- ✅ **市场覆盖广**：支持 A 股、港股、美股
- ✅ **全量股票列表**：支持获取 A 股全量股票代码列表
- ✅ **社区活跃**：持续更新，文档完善
- ✅ **数据源多样**：聚合多个数据源，提高可用性
- ⚠️ **潜在问题**：依赖第三方网站抓取，可能被反爬虫机制影响

**yfinance（美股/港股主数据源）**：
- ✅ **已使用**：已经过验证，稳定可靠
- ✅ **完全免费**：无需注册，无需 API Key
- ✅ **市场覆盖**：支持美股和港股
- ✅ **数据完整**：支持全量股票列表
- ⚠️ **潜在问题**：在中国大陆可能访问受限

**easyquotation（A 股实时行情补充）**：
- ✅ **完全免费**：无需注册，无需 API Key
- ✅ **实时性好**：支持 A 股实时行情数据
- ⚠️ **限制**：不支持全量股票列表，仅用于实时行情补充

#### 第二优先级：需要注册 API Key，存在限制

**Tushare（A 股备用数据源）**：
- ✅ **数据质量高**：官方数据源，准确性高
- ✅ **A 股数据完整**：覆盖 A 股全量股票列表
- ⚠️ **需要 token**：需要注册账号并获取 token
- ⚠️ **积分限制**：免费用户有积分限制

**IEX Cloud（美股备用数据源）**：
- ✅ **免费额度高**：免费版 50,000 次/月
- ✅ **数据质量高**：API 稳定
- ✅ **支持全量列表**：支持获取所有美股股票列表
- ⚠️ **需要 API Key**：需要注册账号

**Alpha Vantage / Finnhub（美股备用数据源）**：
- ✅ **免费版可用**：有免费版（频率限制较严格）
- ✅ **数据质量高**：API 稳定
- ⚠️ **频率限制**：免费版频率限制较严格
- ⚠️ **需要 API Key**：需要注册账号

### 3. 为什么优先选择 akshare 作为 A 股主数据源？

- **符合优先级策略**：免费优先、无需认证
- **功能完整**：支持全量股票列表，支持多市场
- **社区活跃**：持续更新，问题响应及时
- **易于集成**：Python 库，API 简单易用

## 参考资料来源

### 数据源文档

- [Tushare 官方文档](https://tushare.pro/document/2)
- [easyquotation GitHub](https://github.com/shidenggui/easyquotation)
- [stock-api GitHub](https://github.com/zhangxiangliang/stock-api)
- [akshare 文档](https://akshare.akfamily.xyz/)（stock-api 底层依赖）

### 设计模式参考

- [Adapter Pattern](https://refactoring.guru/design-patterns/adapter)
- [Strategy Pattern](https://refactoring.guru/design-patterns/strategy)

## 数据源优先级配置

### 按市场配置数据源优先级

根据**"免费优先、无需认证"**的优先级策略，各市场的数据源配置如下：

#### A 股市场
1. **主数据源**：akshare（第一优先级，免费，无需认证）
2. **备用数据源1**：easyquotation（第一优先级，仅用于实时行情补充）
3. **备用数据源2**：Tushare（第二优先级，需要 token，如果已配置）

#### 美股市场
1. **主数据源**：yfinance（第一优先级，免费，无需认证，已使用）
2. **备用数据源1**：IEX Cloud（第二优先级，需要 API Key，如果已配置）
3. **备用数据源2**：Alpha Vantage（第二优先级，需要 API Key，如果已配置）

#### 港股市场
1. **主数据源**：yfinance（第一优先级，免费，无需认证，已使用）
2. **备用数据源**：akshare（第一优先级，免费，无需认证）

### 数据源选择逻辑

1. **优先使用第一优先级数据源**（免费、无需认证）
2. **如果第一优先级数据源失败，自动切换到备用数据源**
3. **如果配置了第二优先级数据源（API Key），作为增强备用**
4. **支持手动指定首选数据源**（通过 API 参数）

## 待确认事项

### ⚠️ 需要用户确认的关键点

1. **字段扩展范围**：
   - 除了基本信息，是否需要财务指标（PE、PB、市值等）？
   - 是否需要行业分类、概念标签等扩展字段？

2. **第二优先级数据源配置**（可选）：
   - Tushare token（如果已准备好，可作为 A 股备用数据源）
   - IEX Cloud API Key（如果已准备好，可作为美股备用数据源）
   - Alpha Vantage API Key（如果已准备好，可作为美股备用数据源）

3. **市场支持优先级**：
   - 优先支持哪些市场？（A 股、港股、美股）
   - 是否需要支持其他市场（如台股、日股等）？

4. **数据更新策略**：
   - 不同数据源的更新频率是否不同？
   - 是否需要支持数据源级别的更新配置？

---

**数据源优先级策略已确定：免费优先、无需认证为第一优先级**

**可以开始实现第一优先级的数据源适配器**
