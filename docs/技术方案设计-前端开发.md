# 技术方案设计

> 本文档记录项目当前阶段的技术方案设计，包括 Playground 页面实现和 BFF 架构的 API 层设计。

## 项目背景

项目已完成前端重构，使用 Nuxt 4 + Shadcn Vue + TailwindCSS 4 的新架构。当前阶段的主要任务是：

1. **Playground 页面开发**：创建一个统一的 Playground 页面，用于访问和测试三个后端服务（Node.js、Python、Rust）
2. **BFF 架构设计**：为后续采用 BFF（Backend for Frontend）架构做准备，设计新的 API 层

## 项目技术关键点

### 1. 前端技术栈（已确定）
- **框架**：Nuxt 4.1.3
- **UI 组件库**：Shadcn Vue + TailwindCSS 4
- **状态管理**：Pinia
- **HTTP 客户端**：Fetch API
- **类型系统**：TypeScript

### 2. 后端服务（已存在）
- **Node.js 服务**：Nest.js + Bun，端口 3000
- **Python 服务**：FastAPI，端口 8000
- **Rust 服务**：Axum，端口 8080
- **统一 API 格式**：所有服务都遵循统一的响应格式 `{ code, message, data }`

### 3. BFF 架构规划
- **当前阶段**：前端直接调用后端服务
- **目标架构**：通过 BFF 层统一为前端提供服务
- **设计原则**：提前设计 API 层，支持平滑过渡到 BFF

## 架构设计决策

### 1. Playground 页面设计

#### 1.1 页面结构
```
/playground
├── index.vue          # Playground 主页面（服务选择）
└── [service].vue      # 动态路由，对应三个服务
    ├── node.vue       # Node.js 服务测试页面
    ├── python.vue     # Python 服务测试页面
    └── rust.vue        # Rust 服务测试页面
```

#### 1.2 功能设计
- **服务选择界面**：展示三个服务的卡片，点击进入对应的测试页面
- **统一测试界面**：每个服务页面提供相同的 CRUD 操作界面
  - 列表展示（GET /api/v1/items）
  - 创建项目（POST /api/v1/items）
  - 更新项目（PUT /api/v1/items/:id）
  - 删除项目（DELETE /api/v1/items/:id）
- **实时反馈**：显示请求状态、响应数据、错误信息

#### 1.3 UI 组件使用
- **Card**：服务卡片展示
- **Table**：数据列表展示
- **Dialog/Sheet**：创建/编辑表单
- **Button**：操作按钮
- **Toast/Sonner**：消息提示
- **Skeleton**：加载状态

### 2. API 层架构设计（BFF 准备）

#### 2.1 设计目标
- **统一接口**：为前端提供统一的 API 调用接口
- **适配器模式**：支持当前直接调用后端，后续切换到 BFF
- **类型安全**：完整的 TypeScript 类型定义
- **错误处理**：统一的错误处理机制
- **请求拦截**：支持请求/响应拦截（认证、日志等）

#### 2.2 目录结构
```
app/
├── api/
│   ├── client.ts           # 统一 API 客户端
│   ├── adapters/
│   │   ├── index.ts        # 适配器接口定义
│   │   ├── direct.ts       # 直接调用后端适配器（当前使用）
│   │   └── bff.ts          # BFF 适配器（预留）
│   ├── services/
│   │   ├── node.ts         # Node.js 服务 API
│   │   ├── python.ts       # Python 服务 API
│   │   └── rust.ts          # Rust 服务 API
│   ├── types.ts            # API 类型定义
│   └── utils.ts            # API 工具函数
└── composables/
    └── useApi.ts           # API 调用 composable（可选，简化调用）
```

#### 2.3 适配器模式设计

**适配器接口**：
```typescript
interface ApiAdapter {
  get<T>(url: string, config?: RequestConfig): Promise<ApiResponse<T>>
  post<T>(url: string, data?: any, config?: RequestConfig): Promise<ApiResponse<T>>
  put<T>(url: string, data?: any, config?: RequestConfig): Promise<ApiResponse<T>>
  delete<T>(url: string, config?: RequestConfig): Promise<ApiResponse<T>>
}
```

**DirectAdapter（当前使用）**：
- 直接调用后端服务 API
- 使用 Fetch API 发送请求
- 处理跨域、错误等

**BffAdapter（预留）**：
- 调用 BFF 服务 API
- 统一的 API 路径前缀（如 `/api/bff/...`）
- 后续实现具体逻辑

**ApiClient（统一客户端）**：
- 使用依赖注入模式，支持切换适配器
- 提供统一的 API 调用方法
- 支持请求/响应拦截器
- 统一的错误处理

#### 2.4 服务层设计

每个后端服务对应一个服务文件：
- `api/services/node.ts`：Node.js 服务 API 封装
- `api/services/python.ts`：Python 服务 API 封装
- `api/services/rust.ts`：Rust 服务 API 封装

每个服务文件提供：
- 类型定义（Item、CreateItemDto、UpdateItemDto 等）
- CRUD 操作方法（getItems、getItem、createItem、updateItem、deleteItem）
- 统一的错误处理

#### 2.5 配置管理

**环境变量**（`.env`）：
```env
# 后端服务地址（当前使用）
NUXT_PUBLIC_NODE_API_URL=http://localhost:3000
NUXT_PUBLIC_PYTHON_API_URL=http://localhost:8000
NUXT_PUBLIC_RUST_API_URL=http://localhost:8080

# BFF 服务地址（后续使用）
NUXT_PUBLIC_BFF_API_URL=http://localhost:4000
```

**Runtime Config**（`nuxt.config.ts`）：
```typescript
runtimeConfig: {
  public: {
    nodeApiUrl: process.env.NUXT_PUBLIC_NODE_API_URL || 'http://localhost:3000',
    pythonApiUrl: process.env.NUXT_PUBLIC_PYTHON_API_URL || 'http://localhost:8000',
    rustApiUrl: process.env.NUXT_PUBLIC_RUST_API_URL || 'http://localhost:8080',
    bffApiUrl: process.env.NUXT_PUBLIC_BFF_API_URL || 'http://localhost:4000',
  },
}
```

## 技术选型依据

### 1. 适配器模式
- **理由**：支持平滑过渡到 BFF，业务代码无需改动
- **优势**：
  - 业务代码与数据源解耦
  - 切换 BFF 时只需修改适配器配置
  - 便于测试（可 mock 适配器）
  - 支持多数据源（直接调用、BFF、GraphQL 等）

### 2. 统一 API 客户端
- **理由**：提供一致的 API 调用体验，便于维护
- **优势**：
  - 统一的错误处理
  - 统一的请求/响应拦截
  - 类型安全
  - 便于添加功能（缓存、重试等）

### 3. 服务层封装
- **理由**：每个后端服务独立封装，便于管理
- **优势**：
  - 清晰的职责划分
  - 便于扩展和维护
  - 支持服务级别的配置（超时、重试等）

### 4. Playground 页面设计
- **理由**：统一的测试界面，便于验证功能
- **优势**：
  - 快速验证后端服务功能
  - 统一的用户体验
  - 便于后续扩展新服务

## 技术难点与解决方案

### 1. 三个后端服务的 API 差异处理

**问题**：
- Node.js 服务使用 `_id` 字段
- Python/Rust 服务使用 `id` 字段
- 字段命名可能不一致（如 `createdAt` vs `created_at`）

**解决方案**：
- 在服务层进行数据转换，统一为前端使用的格式
- 定义统一的类型定义（`Item`、`CreateItemDto`、`UpdateItemDto`）
- 使用适配器模式，在适配器中处理数据转换

### 2. 错误处理统一

**问题**：
- 不同服务的错误响应格式可能不同
- 需要统一的错误处理机制

**解决方案**：
- 在适配器中统一错误响应格式
- 使用统一的错误类型定义
- 提供错误处理 composable（`useApiError`）

### 3. 请求拦截和认证

**问题**：
- 后续可能需要添加认证、日志等功能
- 需要支持请求/响应拦截

**解决方案**：
- 在 `ApiClient` 中实现拦截器机制
- 支持多个拦截器（请求拦截器、响应拦截器）
- 预留认证相关的配置和拦截器

### 4. BFF 切换的平滑过渡

**问题**：
- 如何确保从直接调用切换到 BFF 时，业务代码无需改动

**解决方案**：
- 使用适配器模式，业务代码只依赖 `ApiClient`
- 通过配置切换适配器（环境变量或配置文件）
- 保持适配器接口一致，确保切换透明

## 参考资料来源

1. **Nuxt 4 文档**：https://nuxt.com/
   - Runtime Config：https://nuxt.com/docs/guide/going-further/runtime-config
   - Composables：https://nuxt.com/docs/guide/directory-structure/composables

2. **Shadcn Vue 文档**：https://www.shadcn-vue.com/
   - 组件使用指南

3. **适配器模式**：
   - 设计模式：适配器模式（Adapter Pattern）
   - 便于后续切换到 BFF 层

4. **BFF 架构**：
   - Backend for Frontend 模式
   - 为前端提供定制化的 API 层

## 实施优先级

### Phase 1：API 层基础架构（核心）
1. 设计适配器接口
2. 实现 DirectAdapter
3. 创建统一 ApiClient
4. 实现服务层封装（Node.js、Python、Rust）

### Phase 2：Playground 页面开发（核心）
1. 创建 Playground 主页面（服务选择）
2. 创建服务测试页面（Node.js、Python、Rust）
3. 实现 CRUD 操作界面
4. 添加加载状态和错误处理

### Phase 3：功能完善（重要）
1. 添加请求/响应拦截器
2. 完善错误处理
3. 添加日志功能
4. 优化用户体验

### Phase 4：BFF 准备（后续）
1. 预留 BffAdapter 接口
2. 设计 BFF API 规范
3. 准备 BFF 服务实现方案

## 注意事项

1. **Keep it Simple**：优先实现核心功能，避免过度设计
2. **类型安全**：确保所有 API 调用都有完整的类型定义
3. **错误处理**：统一的错误处理机制，提供清晰的错误信息
4. **向后兼容**：确保现有功能在重构后仍能正常工作
5. **文档维护**：及时更新文档，保持与代码同步

## 后续扩展点

1. **BFF 服务实现**：创建实际的 BFF 服务
2. **认证系统**：添加认证和授权功能
3. **缓存机制**：添加请求缓存，提升性能
4. **请求重试**：添加自动重试机制
5. **监控和日志**：添加请求监控和日志记录
6. **Mock 数据**：支持 Mock 数据，便于开发测试

---

**创建时间**：2024年
**文档版本**：v1.0
**适用阶段**：Playground 页面开发 + BFF 架构设计
