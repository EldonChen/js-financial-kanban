# 技术方案设计

## 项目概述

本项目是一个金融看板系统，采用前后端分离架构，代码统一管理在 monorepo 结构中。

## 项目技术关键点

### 1. 架构模式
- **前后端分离**：前端与后端完全解耦，通过 RESTful API 通信
- **Monorepo 结构**：统一代码仓库，便于代码共享和版本管理
- **微服务架构**：后端拆分为多个独立服务，每个服务职责单一

### 2. 技术栈选型

#### 前端技术栈
- **框架**：Vue 3（Composition API）
- **元框架**：Nuxt.js 3（提供 SSR/SSG、路由、状态管理等开箱即用功能）
- **构建工具**：Vite（快速开发体验）
- **UI 组件库**：Shadcn UI
- **状态管理**：Pinia（Vue 3 官方推荐）
- **HTTP 客户端**：优先使用Fetch API

#### 后端技术栈
- **Python 服务**：FastAPI（高性能、自动文档生成、类型提示）
  - **包管理**：uv
  - **数据库驱动**：Motor（异步 MongoDB 驱动）
  - **测试框架**：pytest + pytest-asyncio + mongomock-motor
- **Node.js 服务**：Bun + Nest.js
  - **数据库驱动**：Mongoose
  - **测试框架**：Vitest + @nestjs/testing
- **Rust 服务**：Axum（高性能 Web 框架）
  - **包管理**：Cargo
  - **数据库驱动**：mongodb crate
  - **测试框架**：Rust 内置测试框架
- **数据库**：MongoDB（文档数据库，适合金融数据灵活存储）

#### 开发工具
- **包管理**：
  - 前端：pnpm
  - Python：uv
  - Node.js：Bun
  - Rust：Cargo
- **代码格式化**：Prettier（前端）、Black（Python）、rustfmt（Rust）
- **Linting**：ESLint（前端）、pylint（Python）、clippy（Rust）
- **测试框架**：
  - Python：pytest + pytest-asyncio + mongomock-motor
  - Node.js：Vitest + @nestjs/testing
  - Rust：内置测试框架

## 架构设计决策

### 1. Monorepo 结构设计

```
js-financial-kanban/
├── frontend/                 # 前端应用
│   ├── src/
│   ├── pages/               # Nuxt 页面路由
│   ├── components/          # 组件
│   ├── composables/         # 组合式函数
│   ├── stores/              # Pinia 状态管理
│   ├── api/                 # API 调用封装
│   └── nuxt.config.ts
├── services/                # 后端服务
│   ├── python-service/      # Python FastAPI 服务
│   │   ├── app/             # 应用代码
│   │   │   ├── main.py       # 应用入口
│   │   │   ├── config.py     # 配置管理
│   │   │   ├── database.py   # 数据库连接
│   │   │   ├── routers/       # 路由模块
│   │   │   └── schemas/       # Pydantic 模式
│   │   ├── tests/            # 测试代码
│   │   ├── pyproject.toml    # 项目配置
│   │   └── README.md
│   ├── node-service/        # Node.js (Bun + Nest.js) 服务
│   │   ├── src/              # 源代码
│   │   │   ├── main.ts       # 应用入口
│   │   │   ├── app.module.ts # 根模块
│   │   │   ├── items/        # Items 模块
│   │   │   ├── common/       # 通用模块
│   │   │   └── config/       # 配置模块
│   │   ├── vitest.config.ts  # Vitest 配置
│   │   ├── package.json
│   │   └── README.md
│   └── rust-service/        # Rust (Axum) 服务
│       ├── src/             # 源代码
│       │   ├── main.rs      # 应用入口
│       │   ├── database.rs  # 数据库连接
│       │   ├── models/      # 数据模型
│       │   └── handlers/    # 请求处理器
│       ├── tests/           # 集成测试
│       ├── Cargo.toml
│       └── README.md
├── shared/                  # 共享代码（类型定义、工具函数等）
├── docs/                    # 项目文档
├── .gitignore
└── README.md
```

### 2. API 设计规范

- **RESTful 风格**：遵循 REST 设计原则
- **统一响应格式**：
  ```json
  {
    "code": 200,
    "message": "success",
    "data": {}
  }
  ```
- **错误处理**：统一错误码和错误信息格式
- **API 版本控制**：使用 `/api/v1/` 前缀

### 3. 数据库设计

- **MongoDB 集合设计**：按业务模块划分集合
- **数据模型**：使用各语言对应的 ODM/ORM 定义模型
- **连接管理**：每个服务独立管理数据库连接池

## 技术选型依据

### 前端选型理由
1. **Vue 3**：渐进式框架，学习曲线平缓，生态成熟
2. **Nuxt.js 3**：
   - 提供文件系统路由，减少配置
   - 内置 SSR/SSG 支持，提升 SEO 和首屏性能
   - 自动代码分割和优化
   - 内置状态管理、中间件等常用功能

### 后端选型理由
1. **FastAPI**：
   - 基于 Python 3.6+ 类型提示，自动生成 API 文档
   - 性能接近 Node.js 和 Go
   - 异步支持良好
   - 生态丰富，适合快速开发

2. **Node.js**：
   - JavaScript 全栈开发，前后端代码复用
   - 丰富的 npm 生态
   - 事件驱动，适合 I/O 密集型应用

3. **Rust**：
   - 内存安全，无 GC，性能优异
   - 适合高性能计算和数据处理场景
   - 类型系统强大，编译期错误检查

4. **MongoDB**：
   - 文档数据库，灵活的数据模型
   - 适合金融数据的复杂结构
   - 水平扩展能力强

## 技术难点与解决方案

### 1. 跨服务通信
- **问题**：多个后端服务如何通信
- **方案**：初期使用 HTTP REST API，后续可考虑 gRPC 或消息队列

### 2. 数据一致性
- **问题**：多个服务操作同一数据源时的并发控制
- **方案**：使用 MongoDB 事务（4.0+），或通过服务间协调保证一致性

### 3. 前端路由与后端 API 映射
- **问题**：前端需要调用多个后端服务
- **方案**：前端统一 API 网关层，或使用反向代理（Nginx）路由到不同服务

### 4. 开发环境统一
- **问题**：不同语言服务的开发环境配置
- **方案**：使用 Docker Compose 统一管理，或提供详细的本地开发文档

### 6. 部署方案
- **问题**：如何提供独立的部署方案，简化部署流程
- **方案**：为每个服务创建 Dockerfile，使用 Docker Compose 提供 standalone 部署支持

### 5. 类型定义共享
- **问题**：前后端类型定义同步
- **方案**：使用 TypeScript 定义类型，Python 使用 Pydantic，Rust 使用 serde，通过共享目录或代码生成保持同步

## 项目实现状态

### ✅ 已完成

#### 阶段一：项目结构初始化
- ✅ 创建 monorepo 目录结构
- ✅ 初始化各服务的基础配置
- ✅ 配置 Git 忽略文件
- ✅ 创建 README 和开发文档
- ✅ 创建开发规则文件（.cursorrules）

#### 阶段二：后端服务实现（Example 项目）
1. **Python FastAPI 服务** ✅
   - ✅ 实现 Item CRUD API（完整的 RESTful API）
   - ✅ 连接 MongoDB（使用 Motor 异步驱动）
   - ✅ 提供 OpenAPI 文档（自动生成，访问 /docs）
   - ✅ 统一响应格式封装
   - ✅ 错误处理机制
   - ✅ 单元测试框架（pytest + mongomock-motor，16 个测试用例）

2. **Node.js 服务** ✅
   - ✅ 实现 Item CRUD API（完整的 RESTful API）
   - ✅ 连接 MongoDB（使用 Mongoose）
   - ✅ 统一响应格式（拦截器）
   - ✅ 错误处理（异常过滤器）
   - ✅ 单元测试框架（Vitest，16 个测试用例）
   - ✅ 集成测试框架

3. **Rust 服务** ✅
   - ✅ 实现 Item CRUD API（完整的 RESTful API）
   - ✅ 连接 MongoDB（使用 mongodb crate）
   - ✅ 统一响应格式封装
   - ✅ 错误处理机制
   - ✅ 基础测试框架

#### 阶段三：前端实现 ✅
- ✅ 初始化 Nuxt.js 项目
- ✅ 配置 UI 和样式（Tailwind CSS + Shadcn UI）
- ✅ 实现 API 调用封装
- ✅ 为每个后端服务创建对应的示例页面
- ✅ 实现 Item 的增删改查界面

#### 阶段四：Docker 部署方案 ✅
- ✅ 为每个服务创建 Dockerfile（Python、Node.js、Rust、前端）
- ✅ 创建 docker-compose.yml 统一编排所有服务
- ✅ 创建各服务的 .dockerignore 文件，优化构建上下文
- ✅ 配置服务健康检查
- ✅ 实现数据持久化（MongoDB Volume）
- ✅ 更新部署文档和使用说明

### 📋 待完成

#### 阶段五：集成测试和文档
- ⏳ 验证三个后端服务可独立启动
- ⏳ 验证前端可正常调用三个后端 API
- ⏳ 验证 MongoDB 连接正常
- ⏳ 测试完整的 CRUD 流程
- ⏳ 完善项目文档

## 已实现功能

### Python FastAPI 服务
- ✅ Items CRUD API（5 个端点）
- ✅ MongoDB 异步连接（Motor）
- ✅ Pydantic 数据验证
- ✅ 统一响应格式
- ✅ 自动生成 OpenAPI 文档
- ✅ CORS 支持
- ✅ 单元测试（16 个测试用例）
- ✅ Docker 容器化支持

### Node.js Nest.js 服务
- ✅ Items CRUD API（5 个端点）
- ✅ MongoDB 连接（Mongoose）
- ✅ 统一响应格式（拦截器）
- ✅ 错误处理（异常过滤器）
- ✅ 数据验证（class-validator）
- ✅ CORS 支持
- ✅ 单元测试（16 个测试用例，使用 Vitest）
- ✅ Docker 容器化支持

### Rust Axum 服务
- ✅ Items CRUD API（5 个端点）
- ✅ MongoDB 连接（mongodb crate）
- ✅ 统一响应格式
- ✅ 错误处理
- ✅ CORS 支持（tower-http）
- ✅ 基础测试框架
- ✅ Docker 容器化支持

### 前端 Nuxt.js 应用
- ✅ Nuxt.js 3 项目初始化
- ✅ Tailwind CSS + Shadcn UI 配置
- ✅ API 调用封装（Fetch API）
- ✅ 三个服务的示例页面（CRUD 功能）
- ✅ Docker 容器化支持

### Docker 部署方案
- ✅ 各服务独立的 Dockerfile
- ✅ Docker Compose 统一编排
- ✅ 构建上下文优化（.dockerignore）
- ✅ 服务健康检查配置
- ✅ 数据持久化支持
- ✅ 网络和服务发现配置

## 参考资料来源

- [Nuxt.js 3 官方文档](https://nuxt.com/)
- [FastAPI 官方文档](https://fastapi.tiangolo.com/)
- [Nest.js 官方文档](https://nestjs.com/)
- [Axum 官方文档](https://docs.rs/axum/)
- [Vitest 官方文档](https://vitest.dev/)
- [MongoDB Node.js 驱动](https://www.mongodb.com/docs/drivers/node/current/)
- [MongoDB Rust 驱动](https://www.mongodb.com/docs/drivers/rust/)
- [Motor (Python MongoDB 异步驱动)](https://motor.readthedocs.io/)

## 部署方案

### Docker 容器化部署

项目提供完整的 Docker 容器化部署方案，支持 standalone 部署。

#### 架构设计

- **每个服务独立容器化**：Python、Node.js、Rust 服务和前端各自拥有独立的 Dockerfile
- **统一编排**：使用 Docker Compose 管理所有服务
- **数据持久化**：MongoDB 数据使用 Docker Volume 持久化存储
- **服务发现**：通过 Docker 网络实现服务间通信

#### 容器化策略

1. **Python 服务**
   - 基础镜像：`python:3.11-slim`
   - 包管理：使用 `uv` 进行依赖管理
   - 构建优化：多阶段构建（如需要）
   - 运行命令：`uv run uvicorn app.main:app --host 0.0.0.0 --port 8000`

2. **Node.js 服务**
   - 基础镜像：`oven/bun:1`（构建阶段）、`oven/bun:1-slim`（运行阶段）
   - 包管理：使用 Bun 进行依赖管理
   - 构建优化：多阶段构建，分离构建和运行环境
   - 运行命令：`bun run start:prod`

3. **Rust 服务**
   - 基础镜像：`rust:1.75-slim`（构建阶段）、`debian:bookworm-slim`（运行阶段）
   - 构建优化：多阶段构建，最小化运行时镜像
   - 运行命令：直接运行编译后的二进制文件

4. **前端服务**
   - 基础镜像：`node:20-alpine`
   - 包管理：使用 pnpm 进行依赖管理
   - 构建优化：多阶段构建，只复制构建产物
   - 运行命令：`node .output/server/index.mjs`（Nuxt 3 生产模式）

#### Docker Compose 配置

- **服务编排**：MongoDB、Python 服务、Node.js 服务、Rust 服务、前端服务
- **网络配置**：使用 bridge 网络，服务间通过服务名通信
- **健康检查**：为每个服务配置健康检查
- **依赖管理**：通过 `depends_on` 和 `condition: service_healthy` 确保服务启动顺序
- **数据卷**：MongoDB 数据持久化到命名卷

#### 部署步骤

1. **构建镜像**：
   ```bash
   docker-compose build
   ```

2. **启动服务**：
   ```bash
   docker-compose up -d
   ```

3. **查看日志**：
   ```bash
   docker-compose logs -f
   ```

4. **停止服务**：
   ```bash
   docker-compose down
   ```

5. **清理数据**（谨慎使用）：
   ```bash
   docker-compose down -v
   ```

#### 环境变量配置

各服务通过环境变量配置，支持：
- MongoDB 连接字符串
- 服务端口配置
- API 基础 URL（前端）
- 其他运行时配置

详细配置请参考各服务的 `.env.example` 文件和 `docker-compose.yml`。

## 技术决策记录

### 已确认的技术选型
1. ✅ **前端 UI 组件库**：Shadcn UI + Tailwind CSS
2. ✅ **Node.js 框架**：Bun + Nest.js
3. ✅ **Rust Web 框架**：Axum
4. ✅ **包管理工具**：pnpm（前端）、uv（Python）、Bun（Node.js）、Cargo（Rust）
5. ✅ **测试框架**：pytest（Python）、Vitest（Node.js）、内置测试（Rust）
6. ✅ **部署方案**：Docker + Docker Compose（standalone 部署）

---

**最后更新**：2024年
**当前状态**：所有核心功能已完成，Docker 部署方案已实现并优化
