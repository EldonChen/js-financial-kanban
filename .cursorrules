# 项目开发通用规则

> 本文档定义了本项目的开发规范和 AI 协作规则，所有 AI 助手必须严格遵守。

## 🚨 代码质量保证（最高优先级）

### 核心原则
- **代码质量检查拥有绝对最高优先级**
- 禁止与任何其他操作（代码变更、提交等）并行执行
- 必须在以下关键节点执行质量检查：

### 强制检查点
1. **项目初始化后** - 确保基础架构正确
2. **任务标记完成前** - 验证功能实现
3. **Git 提交前** - 保证代码稳定性
4. **版本发布前** - 最终质量验证

### 检查标准
- ✅ **编译通过**：代码在所有目标环境可编译
- ✅ **执行成功**：程序运行符合预期
- ✅ **测试通过**：所有单元测试和 CI/CD 流程成功
- ✅ **功能验证**：核心功能按需求正常工作

### 单元测试要求（重要）

#### 测试时机
- **每次引入大的 feature 后**：必须编写对应的单元测试
- **每次实现核心功能模块后**：必须编写单元测试
- **每次修复重要 bug 后**：必须添加回归测试

#### 测试覆盖范围
- **API 端点**：所有 RESTful API 端点必须有测试
- **业务逻辑**：Service/Handler 层的核心逻辑必须有测试
- **数据模型**：数据验证和转换逻辑必须有测试
- **错误处理**：异常情况和边界条件必须有测试

#### 测试质量标准
- 测试用例应该覆盖正常流程和异常流程
- 测试应该独立、可重复、快速执行
- 测试命名清晰，描述测试意图
- 测试代码应该保持简洁，避免过度复杂

#### 测试框架
- **Python**: pytest + pytest-asyncio
- **Node.js**: Jest (Nest.js 内置)
- **Rust**: 内置测试框架 (cargo test)

---

## 📋 需求分析与技术方案

### 技术方案文档管理
- **创建文件**：`技术方案设计.md`
- **维护责任**：持续更新，确保文档与实际实现同步

### 必需内容结构
```markdown
# 技术方案设计

## 项目技术关键点
- [列出核心技术要点]

## 架构设计决策
- [记录架构选择及理由]

## 技术选型依据
- [说明技术栈选择原因]

## 技术难点与解决方案
- [详细分析技术挑战]

## 参考资料来源
- [列出研究资料链接]
```

### 技术难点研究流程
1. **识别难点** → 2. **网络搜索** → 3. **收集资料** → 4. **可行性论证** → 5. **文档记录**

### ⚠️ 重要：用户确认机制
- 技术方案必须经用户确认后才能进入实现阶段
- 在获得确认前，不得开始详细设计或编码

---

## 🗺️ 技术路线与任务管理

### 技术路线文档规范
- **命名格式**：`技术路线-{任务名称}.md`
- **作用范围**：仅用于当前任务，任务完成后可归档或删除
- **必需内容**：
  - 任务拆解（细化到可执行的最小单元）
  - 任务状态跟踪（待开始/进行中/已完成/已取消/阻塞中）
  - 任务依赖关系
  - 注意事项和检查清单

### 任务状态更新
- 开始任务时：将状态更新为"进行中"
- 完成任务时：立即更新为"已完成"
- 遇到阻塞时：更新为"阻塞中"并说明原因
- 取消任务时：更新为"已取消"并说明原因

### 任务拆分策略

#### 拆分原则
根据任务规模和复杂度，动态决定拆分粒度：

1. **小任务**（单一职责、简单实现）：
   - 可保持为单一任务
   - 例如：修复单个 bug、添加单个 API 端点、更新单个文档
   - 拆分标准：预计工作量 < 2 小时，无复杂依赖关系

2. **中大型任务**（多步骤、有依赖关系）：
   - **必须拆分为多个子任务**
   - 拆分标准：
     - 预计工作量 > 2 小时
     - 包含多个独立的功能模块
     - 存在明确的依赖关系（如：先搭建基础架构，再实现功能）
     - 需要分阶段验证和测试

3. **拆分粒度要求**：
   - 每个子任务应该是**可独立执行的最小单元**
   - 每个子任务应该有**明确的完成标准**
   - 每个子任务应该有**清晰的依赖关系**
   - 避免创建职责过于庞杂的单一任务

#### 拆分示例

**✅ 好的拆分**：
```
任务：实现用户认证系统
├── 子任务 1：设计认证数据模型和 Schema
├── 子任务 2：实现用户注册 API
├── 子任务 3：实现用户登录 API
├── 子任务 4：实现 JWT Token 生成和验证
└── 子任务 5：添加认证中间件
```

**❌ 不好的拆分**：
```
任务：实现完整的用户管理系统（包含注册、登录、权限、个人资料、密码重置等所有功能）
```

### Vibe-Kanban 任务管理

#### 自动创建任务的条件

当用户表达以下意图时，Agent 应自动创建 vibe-kanban 任务：

1. **明确意图**：
   - 用户明确要求"创建任务"、"添加到看板"、"记录任务"等
   - 用户描述了一个需要跟踪的待办事项

2. **隐含意图**：
   - 用户描述了一个需要多步骤完成的功能或需求
   - 用户提出了一个需要后续跟进的问题或改进点
   - 用户要求实现一个复杂功能（符合中大型任务拆分标准）

3. **不应创建任务的情况**：
   - 简单的代码修改（如修复单个 bug、调整样式）
   - 立即可以完成的简单任务
   - 用户明确表示不需要创建任务

#### 任务创建流程

1. **识别任务需求**：
   - 分析用户意图，判断是否需要创建任务
   - 确定任务规模和拆分需求

2. **获取项目信息**：
   - 使用 `mcp_vibe_kanban_list_projects` 获取项目列表
   - 确定当前项目 ID（默认：js-financial-kanban 项目）

3. **创建任务**：
   - 使用 `mcp_vibe_kanban_create_task` 创建任务
   - 提供清晰的任务标题和描述（遵循任务描述规范）

4. **任务拆分**（如需要）：
   - 如果任务规模较大，创建主任务后，可创建多个子任务
   - 在任务描述中说明任务拆分和依赖关系

#### 任务描述规范（AI Agent 友好）

创建 vibe-kanban 任务时，任务描述应遵循以下结构：

```markdown
## 背景（Context）
[说明任务的背景和原因]

## 目标（Goals）
[列出明确的目标，使用列表格式]

## 任务范围（Scope）
[详细说明任务包含的内容和不包含的内容]

## 关键约束与注意事项（Constraints & Guidelines）
[列出重要的约束条件、技术要求、注意事项]

## 预期产出（Expected Deliverables）
[列出可交付的成果，包括代码、文档、测试等]

## 验收标准（Acceptance Criteria）
[列出明确的验收标准，用于判断任务是否完成]
```

**描述要求**：
- ✅ **目标清晰**：每个目标都是可衡量的
- ✅ **背景充分**：提供足够的上下文信息
- ✅ **边界明确**：清楚说明包含和不包含的内容
- ✅ **可拆解**：如果任务较大，说明如何拆分为子任务
- ✅ **可执行**：描述足够详细，AI Agent 可以直接执行

**示例**：

```markdown
## 背景（Context）
项目需要添加用户认证功能，支持用户注册、登录和 JWT Token 验证。

## 目标（Goals）
1. 实现用户注册 API
2. 实现用户登录 API
3. 实现 JWT Token 生成和验证
4. 添加认证中间件保护受保护的路由

## 任务范围（Scope）
- 包含：用户数据模型、注册/登录 API、JWT 实现、认证中间件
- 不包含：密码重置、邮箱验证、第三方登录（后续任务）

## 关键约束与注意事项（Constraints & Guidelines）
- 使用项目既有的技术栈（FastAPI + MongoDB）
- 密码必须加密存储（使用 bcrypt）
- JWT Token 有效期：7 天
- 需要添加单元测试

## 预期产出（Expected Deliverables）
1. 用户数据模型和 Schema
2. 注册和登录 API 端点
3. JWT 工具函数
4. 认证中间件
5. 单元测试（覆盖率 > 80%）
6. API 文档更新

## 验收标准（Acceptance Criteria）
- [ ] 用户可以通过 API 注册新账户
- [ ] 用户可以使用邮箱和密码登录
- [ ] 登录后返回有效的 JWT Token
- [ ] 受保护的路由需要有效的 Token 才能访问
- [ ] 所有单元测试通过
- [ ] API 文档已更新
```

#### MCP 工具使用说明

可用的 MCP 工具：
- `mcp_vibe_kanban_list_projects` - 获取项目列表
- `mcp_vibe_kanban_list_tasks` - 获取任务列表
- `mcp_vibe_kanban_create_task` - 创建任务（需要 `project_id` 和 `title`）
- `mcp_vibe_kanban_get_task` - 获取任务详情
- `mcp_vibe_kanban_update_task` - 更新任务（状态、标题、描述等）
- `mcp_vibe_kanban_delete_task` - 删除任务

**重要提示**：
- 创建任务时，**必须提供 `project_id`**
- 可以通过 `list_projects` 获取项目 ID
- 默认项目：js-financial-kanban（ID: `d462488b-568a-4fc0-9f20-200db4db8bb6`）

---

## 🔄 版本控制规范

### Git 提交策略（重要）

#### 提交时机
1. **AI 完成代码后**：不立即提交，等待用户修改
2. **下次对话开始时**：
   - 首先汇总 AI 的代码变更和用户的修改
   - 识别所有变更的文件和内容
   - 进行 Git 提交（包含完整的变更说明）
   - 提交完成后再开始新的对话任务

#### 提交前检查清单
- [ ] 代码已通过质量检查
- [ ] 已汇总所有变更（AI + 用户）
- [ ] 提交信息清晰描述变更内容
- [ ] 遵循提交信息规范

#### 提交信息规范（遵循 Conventional Commits）

提交信息必须遵循以下格式：

```
<类型>(<范围>): <简短描述>

<详细说明（可选，空行分隔）>

<脚注（可选）>
```

**格式说明**：

1. **类型（必填）**：使用以下标准类型之一
   - `feat`: 新功能（feature）
   - `fix`: 修复 bug
   - `docs`: 仅文档变更
   - `style`: 代码格式变更（不影响代码运行，如空格、格式化、缺少分号等）
   - `refactor`: 代码重构（既不是新功能也不是 bug 修复）
   - `perf`: 性能优化
   - `test`: 添加或修改测试
   - `build`: 构建系统或外部依赖的变更（如 npm、webpack、gulp 等）
   - `ci`: CI 配置文件和脚本的变更
   - `chore`: 其他变更（不修改 src 或 test 文件）
   - `revert`: 回滚之前的提交

2. **范围（可选）**：指定变更影响的范围
   - 可以是模块名、服务名、组件名等
   - 例如：`feat(python-service)`, `fix(frontend)`, `refactor(items-api)`
   - 如果变更影响多个范围，可以省略范围或使用 `*`

3. **简短描述（必填）**：
   - 使用祈使语气，首字母小写，结尾不加句号
   - 不超过 72 个字符
   - 清晰描述提交做了什么

4. **详细说明（可选）**：
   - 空行分隔
   - 解释"为什么"而不是"做了什么"（做了什么在标题中已说明）
   - 可以包含变更的动机和与之前行为的对比

5. **脚注（可选）**：
   - `BREAKING CHANGE:` 后跟破坏性变更的描述
   - 或引用相关 issue：`Closes #123`, `Fixes #456`

**提交信息示例**：

```
feat(python-service): 添加 Items CRUD API

实现了完整的 Items 增删改查功能，包括：
- GET /api/v1/items - 获取所有 items
- GET /api/v1/items/{id} - 获取单个 item
- POST /api/v1/items - 创建 item
- PUT /api/v1/items/{id} - 更新 item
- DELETE /api/v1/items/{id} - 删除 item

使用 Motor 异步 MongoDB 驱动，提供统一的响应格式。

Closes #10
```

```
fix(node-service): 修复 Mongoose Schema 类型定义

在 Vitest 环境下，Mongoose Schema 需要显式指定 type 字段
以避免类型推断错误。

- 为所有 @Prop 装饰器添加 type 字段
- 修复了测试中的类型错误
```

```
refactor(test): 将 Node.js 测试框架从 Jest 迁移到 Vitest

- 移除 Jest 相关依赖和配置
- 添加 Vitest 配置文件和依赖
- 更新所有测试文件使用 Vitest API
- 修复测试兼容性问题

BREAKING CHANGE: 测试命令从 `jest` 改为 `vitest run`
```

```
docs: 更新 README 添加测试说明

添加了测试运行命令和测试框架说明。
```

**提交信息检查清单**：
- [ ] 类型使用标准类型之一
- [ ] 简短描述使用祈使语气，首字母小写
- [ ] 简短描述不超过 72 个字符
- [ ] 如果有详细说明，用空行分隔
- [ ] 破坏性变更已标注 `BREAKING CHANGE:`
- [ ] 相关 issue 已引用

### 分支管理策略
- 推荐从 main 创建功能分支：`feature/xxx`
- 在功能分支开发
- 合并前整理提交历史
- 使用临时分支 + cherry-pick 优化提交顺序

---

## 📝 开发过程记录

### 变更日志管理
- **文件**：`changelog.md`
- **文档开头**：必须说明文档功能和内容，便于 AI 获取上下文

### 初始记录格式
```markdown
# 开发变更日志

> 本文档记录项目开发过程中的重要变更，为后续 AI 协作提供上下文参考

## Commit-00 项目概述

### 技术栈信息
- [列出使用的技术栈]

### 项目结构
- [描述项目目录结构]

### 启动命令
- [记录开发/构建/部署命令]

### 其他关键信息
- [补充重要配置或说明]
```

### 提交记录规范
每次 Git 提交后添加新章节：

```markdown
## Commit-XX [提交标题]

### 主要变更点
- [列出核心变更]

### 详细变更说明
- [用自然语言解释变更原因和影响]

### 关键代码片段
```language
// 展示重要代码变更（不贴完整代码）
```

### 注意事项
- [记录需要注意的问题或后续工作]
```

### 📌 内容管理原则
- ✅ **仅允许追加**：只能在文档末尾添加新内容
- ⚠️ **过时标记**：对过时内容在开头标注 `（已过时）`
- 🚫 **禁止删除**：严禁删除或修改已存在的内容
- 📋 **保持完整**：确保开发历史的完整性和可追溯性

---

## 🛠️ 项目技术栈规范

### 前端
- **框架**：Vue 3 (Composition API)
- **元框架**：Nuxt.js 3
- **UI 组件库**：Shadcn UI + Tailwind CSS
- **状态管理**：Pinia
- **HTTP 客户端**：优先使用 Fetch API
- **包管理**：pnpm

### 后端服务
- **Python 服务**：FastAPI
  - **包管理**：uv
  - **数据库驱动**：Motor（异步）或 PyMongo
- **Node.js 服务**：Bun + Nest.js
  - **数据库驱动**：Mongoose
- **Rust 服务**：Axum
  - **包管理**：Cargo
  - **数据库驱动**：mongodb crate

### 数据库
- **类型**：MongoDB
- **连接管理**：每个服务独立管理数据库连接池

### 开发工具
- **代码格式化**：
  - 前端：Prettier
  - Python：Black
  - Rust：rustfmt
- **Linting**：
  - 前端：ESLint
  - Python：pylint
  - Rust：clippy

---

## 📁 项目结构规范

### Monorepo 结构
```
js-financial-kanban/
├── frontend/                 # 前端应用（Nuxt.js）
│   ├── pages/               # Nuxt 页面路由
│   ├── components/          # 组件
│   ├── composables/         # 组合式函数
│   ├── stores/              # Pinia 状态管理
│   ├── api/                 # API 调用封装
│   └── nuxt.config.ts
├── services/                # 后端服务
│   ├── python-service/      # Python FastAPI 服务
│   ├── node-service/        # Node.js (Bun + Nest.js) 服务
│   └── rust-service/        # Rust (Axum) 服务
├── shared/                  # 共享代码（类型定义、工具函数等）
├── docs/                    # 项目文档
├── .gitignore
├── .cursorrules            # 本规则文件
└── README.md
```

---

## 🔌 API 设计规范

### RESTful 风格
- 遵循 REST 设计原则
- 使用标准 HTTP 方法（GET、POST、PUT、DELETE）
- 资源命名使用复数形式（如 `/api/v1/items`）

### 统一响应格式
```json
{
  "code": 200,
  "message": "success",
  "data": {}
}
```

### API 版本控制
- 使用 `/api/v1/` 前缀
- 后续版本使用 `/api/v2/` 等

### 错误处理
- 统一错误码和错误信息格式
- 提供清晰的错误提示

---

## 🤖 AI 助手执行指南

### 行为优先级
1. **代码质量保证** (最高优先级)
2. **用户需求确认**
3. **技术方案验证**
4. **标准流程执行**
5. **文档维护更新**

### 执行检查清单
- [ ] 质量检查点已通过
- [ ] 技术方案已确认
- [ ] Git 状态正常
- [ ] 文档已更新
- [ ] 用户已告知关键信息

### 对话开始流程
1. **检查 Git 状态**：查看是否有未提交的变更
2. **汇总变更**：识别 AI 和用户的代码变更
3. **提交 Git**：如有变更，先提交再开始新任务
   - 使用规范的提交信息格式（Conventional Commits）
   - 确保提交信息清晰、完整
4. **读取上下文**：查看 changelog.md 和技术路线文档
5. **识别任务需求**：
   - 分析用户意图，判断是否需要创建 vibe-kanban 任务
   - 如果符合创建条件，自动创建任务（遵循任务创建流程）
   - 如果任务规模较大，进行任务拆分
6. **执行任务**：按照技术路线执行具体任务
7. **更新状态**：实时更新任务状态（技术路线文档和 vibe-kanban 任务）
8. **质量检查**：完成任务后进行质量验证

### 对话结束流程
1. **更新文档**：更新 changelog.md 和技术路线文档
2. **更新任务状态**：
   - 如果创建了 vibe-kanban 任务，更新任务状态（如：进行中 → 已完成）
   - 更新技术路线文档中的任务状态
3. **不提交 Git**：等待用户修改，下次对话时再提交
4. **总结工作**：向用户说明已完成的工作和待办事项

---

## 📚 文档管理规范

### 必需文档
- `README.md` - 项目介绍和快速开始
- `技术方案设计.md` - 技术架构和选型
- `changelog.md` - 开发变更日志
- `技术路线-{任务名称}.md` - 任务拆解和进度跟踪

### 文档更新原则
- 技术方案变更时，必须同步更新文档
- 每次提交后，更新 changelog.md
- 任务状态变更时，更新技术路线文档
- 保持文档与代码同步

---

## ⚠️ 注意事项

1. **严格遵守优先级**：代码质量 > 用户需求 > 流程规范
2. **用户确认机制**：重要决策必须等待用户确认
3. **Git 提交时机**：不立即提交，等用户修改后下次对话时提交
4. **文档完整性**：保持所有文档的完整性和可追溯性
5. **任务状态跟踪**：实时更新任务状态，确保进度透明
6. **任务拆分原则**：中大型任务必须拆分，避免创建职责过于庞杂的单一任务
7. **任务创建时机**：识别用户意图，在合适场景下自动创建 vibe-kanban 任务
8. **任务描述质量**：创建任务时，必须提供清晰、结构化、AI Agent 友好的任务描述

---

**最后更新**：2025年1月
**适用项目**：js-financial-kanban
**规则版本**：v1.1

### 版本更新记录

#### v1.1 (2025-01)
- ✅ 新增任务拆分策略：根据任务规模动态决定拆分粒度
- ✅ 新增 Vibe-Kanban 任务管理：支持自动创建和管理任务
- ✅ 新增任务描述规范：AI Agent 友好的结构化描述格式
- ✅ 优化 AI 助手执行指南：明确任务创建时机和流程
- ✅ 对齐实际开发流程：基于近期开发实践更新规则
